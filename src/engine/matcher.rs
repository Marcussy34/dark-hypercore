//! Core matching engine implementation.
//!
//! ## Algorithm
//!
//! The matching algorithm follows price-time priority:
//!
//! 1. Get the best opposite price level
//! 2. Check if prices are compatible for matching
//! 3. Match against orders at that level (FIFO)
//! 4. Continue until no more matches or order is filled
//! 5. If remaining quantity, add to book (limit orders)
//!
//! ## Determinism
//!
//! Critical for consensus - the matching engine must be 100% deterministic:
//!
//! - No floating-point operations
//! - No random numbers
//! - Timestamps passed in (not from system)
//! - BTreeMap for deterministic iteration order
//! - Synchronous execution only

use std::cmp::Reverse;
use crate::orderbook::CLOB;
use crate::types::{Order, Side, Trade};

/// Result of matching a single order against the book.
#[derive(Debug, Clone)]
pub struct MatchResult {
    /// The original order (may be modified with filled quantity)
    pub order: Order,
    
    /// Trades generated by the match
    pub trades: Vec<Trade>,
    
    /// Whether the order was fully filled
    pub fully_filled: bool,
    
    /// Remaining quantity (0 if fully filled)
    pub remaining: u64,
    
    /// Slab key if the order was added to the book (partial/no fill)
    pub resting_key: Option<usize>,
}

impl MatchResult {
    /// Create a new match result for a fully filled order
    fn fully_filled(order: Order, trades: Vec<Trade>) -> Self {
        Self {
            order,
            trades,
            fully_filled: true,
            remaining: 0,
            resting_key: None,
        }
    }
    
    /// Create a new match result for a partially filled order
    fn partial_fill(order: Order, trades: Vec<Trade>, remaining: u64, resting_key: Option<usize>) -> Self {
        Self {
            order,
            trades,
            fully_filled: false,
            remaining,
            resting_key,
        }
    }
    
    /// Create a new match result for an order with no matches (resting on book)
    fn no_match(order: Order, resting_key: usize) -> Self {
        let remaining = order.remaining;
        Self {
            order,
            trades: Vec::new(),
            fully_filled: false,
            remaining,
            resting_key: Some(resting_key),
        }
    }
}

/// Deterministic order matching engine.
///
/// The matching engine is stateless - all state is stored in the CLOB.
/// This design ensures determinism and simplifies testing.
#[derive(Debug, Default)]
pub struct MatchingEngine {
    // No state - all state is in the CLOB
}

impl MatchingEngine {
    /// Create a new matching engine
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Process an incoming order against the book.
    ///
    /// # Arguments
    ///
    /// * `clob` - The order book
    /// * `incoming` - The incoming order
    /// * `timestamp` - Current timestamp (for trade records)
    ///
    /// # Returns
    ///
    /// A `MatchResult` containing trades and order status
    ///
    /// # Matching Rules
    ///
    /// 1. Buy orders match against asks (low to high)
    /// 2. Sell orders match against bids (high to low)
    /// 3. Price-time priority (FIFO at same price)
    /// 4. Partial fills allowed
    /// 5. Unfilled quantity rests on book (limit orders)
    ///
    /// # Example
    ///
    /// ```
    /// use dark_hypercore::engine::MatchingEngine;
    /// use dark_hypercore::orderbook::CLOB;
    /// use dark_hypercore::types::{Order, Side};
    ///
    /// let mut clob = CLOB::with_capacity(100);
    /// let mut engine = MatchingEngine::new();
    ///
    /// // Add resting order
    /// clob.add_order(Order::new(1, 100, Side::Sell, 5_000_000_000_000, 100_000_000, 0));
    ///
    /// // Match incoming order
    /// let buy = Order::new(2, 101, Side::Buy, 5_000_000_000_000, 100_000_000, 0);
    /// let result = engine.match_order(&mut clob, buy, 0);
    ///
    /// assert!(result.fully_filled);
    /// ```
    pub fn match_order(&mut self, clob: &mut CLOB, mut incoming: Order, timestamp: u64) -> MatchResult {
        let mut trades = Vec::new();
        let mut remaining = incoming.remaining;
        
        // Match based on order side
        match incoming.side() {
            Side::Buy => {
                // Buy orders match against asks (lowest price first)
                remaining = self.match_against_asks(clob, &incoming, remaining, timestamp, &mut trades);
            }
            Side::Sell => {
                // Sell orders match against bids (highest price first)
                remaining = self.match_against_bids(clob, &incoming, remaining, timestamp, &mut trades);
            }
        }
        
        // Update the incoming order's remaining quantity
        incoming.remaining = remaining;
        
        // Determine result based on remaining quantity
        if remaining == 0 {
            // Fully filled
            MatchResult::fully_filled(incoming, trades)
        } else {
            // Partial or no fill - add to book if limit order
            let resting_key = clob.add_order(incoming.clone());
            
            if trades.is_empty() {
                MatchResult::no_match(incoming, resting_key)
            } else {
                MatchResult::partial_fill(incoming, trades, remaining, Some(resting_key))
            }
        }
    }
    
    /// Match a buy order against asks (lowest price first)
    fn match_against_asks(
        &mut self,
        clob: &mut CLOB,
        incoming: &Order,
        mut remaining: u64,
        timestamp: u64,
        trades: &mut Vec<Trade>,
    ) -> u64 {
        let incoming_price = incoming.price;
        
        // Process price levels until no more matches
        while remaining > 0 {
            // Get best ask price
            let best_ask_price = match clob.asks().keys().next().copied() {
                Some(p) => p,
                None => break, // No more asks
            };
            
            // Check if price is compatible
            // Buy matches if book price <= incoming price
            if best_ask_price > incoming_price {
                break; // No more compatible prices
            }
            
            // Collect matching info from this price level
            let matches = self.collect_matches_at_ask_level(clob, remaining, best_ask_price);
            
            if matches.is_empty() {
                break;
            }
            
            // Execute the matches
            for (key, order_id, maker_user_id, fill_qty, fully_filled) in matches {
                // Create trade record
                let trade_id = clob.next_trade_id();
                let trade = Trade::new(
                    trade_id,
                    order_id,               // maker_order_id
                    incoming.id,            // taker_order_id
                    maker_user_id,          // maker_user_id
                    incoming.user_id,       // taker_user_id
                    best_ask_price,         // execution price
                    fill_qty,               // quantity
                    timestamp,
                );
                trades.push(trade);
                
                // Update remaining
                remaining -= fill_qty;
                
                // Fill the maker order
                if let Some(node) = clob.orders_mut().get_mut(key) {
                    node.fill(fill_qty);
                }
                
                // Update price level quantity
                if let Some(level) = clob.asks_mut().get_mut(&best_ask_price) {
                    level.reduce_quantity(fill_qty);
                }
                
                // Remove fully filled orders
                if fully_filled {
                    self.remove_ask_order(clob, key, order_id, best_ask_price);
                }
            }
            
            // Remove empty price level
            if let Some(level) = clob.asks().get(&best_ask_price) {
                if level.is_empty() {
                    clob.remove_ask_level(best_ask_price);
                }
            }
        }
        
        remaining
    }
    
    /// Match a sell order against bids (highest price first)
    fn match_against_bids(
        &mut self,
        clob: &mut CLOB,
        incoming: &Order,
        mut remaining: u64,
        timestamp: u64,
        trades: &mut Vec<Trade>,
    ) -> u64 {
        let incoming_price = incoming.price;
        
        // Process price levels until no more matches
        while remaining > 0 {
            // Get best bid price
            let best_bid_price = match clob.bids().keys().next().map(|r| r.0) {
                Some(p) => p,
                None => break, // No more bids
            };
            
            // Check if price is compatible
            // Sell matches if book price >= incoming price
            if best_bid_price < incoming_price {
                break; // No more compatible prices
            }
            
            // Collect matching info from this price level
            let matches = self.collect_matches_at_bid_level(clob, remaining, best_bid_price);
            
            if matches.is_empty() {
                break;
            }
            
            // Execute the matches
            for (key, order_id, maker_user_id, fill_qty, fully_filled) in matches {
                // Create trade record
                let trade_id = clob.next_trade_id();
                let trade = Trade::new(
                    trade_id,
                    order_id,               // maker_order_id
                    incoming.id,            // taker_order_id
                    maker_user_id,          // maker_user_id
                    incoming.user_id,       // taker_user_id
                    best_bid_price,         // execution price
                    fill_qty,               // quantity
                    timestamp,
                );
                trades.push(trade);
                
                // Update remaining
                remaining -= fill_qty;
                
                // Fill the maker order
                if let Some(node) = clob.orders_mut().get_mut(key) {
                    node.fill(fill_qty);
                }
                
                // Update price level quantity
                if let Some(level) = clob.bids_mut().get_mut(&Reverse(best_bid_price)) {
                    level.reduce_quantity(fill_qty);
                }
                
                // Remove fully filled orders
                if fully_filled {
                    self.remove_bid_order(clob, key, order_id, best_bid_price);
                }
            }
            
            // Remove empty price level
            if let Some(level) = clob.bids().get(&Reverse(best_bid_price)) {
                if level.is_empty() {
                    clob.remove_bid_level(best_bid_price);
                }
            }
        }
        
        remaining
    }
    
    /// Collect orders to match at an ask price level (read-only scan)
    ///
    /// Returns: Vec<(key, order_id, user_id, fill_qty, fully_filled)>
    fn collect_matches_at_ask_level(
        &self,
        clob: &CLOB,
        mut remaining: u64,
        price: u64,
    ) -> Vec<(usize, u64, u64, u64, bool)> {
        let mut matches = Vec::new();
        
        let level = match clob.asks().get(&price) {
            Some(l) => l,
            None => return matches,
        };
        
        let mut current_key = level.head;
        
        while remaining > 0 && current_key.is_some() {
            let key = current_key.unwrap();
            
            let node = match clob.orders().get(key) {
                Some(n) => n,
                None => break,
            };
            
            let order_id = node.order.id;
            let user_id = node.order.user_id;
            let maker_remaining = node.remaining();
            
            // Calculate fill quantity
            let fill_qty = remaining.min(maker_remaining);
            let fully_filled = fill_qty >= maker_remaining;
            
            matches.push((key, order_id, user_id, fill_qty, fully_filled));
            
            remaining -= fill_qty;
            current_key = node.next;
        }
        
        matches
    }
    
    /// Collect orders to match at a bid price level (read-only scan)
    ///
    /// Returns: Vec<(key, order_id, user_id, fill_qty, fully_filled)>
    fn collect_matches_at_bid_level(
        &self,
        clob: &CLOB,
        mut remaining: u64,
        price: u64,
    ) -> Vec<(usize, u64, u64, u64, bool)> {
        let mut matches = Vec::new();
        
        let level = match clob.bids().get(&Reverse(price)) {
            Some(l) => l,
            None => return matches,
        };
        
        let mut current_key = level.head;
        
        while remaining > 0 && current_key.is_some() {
            let key = current_key.unwrap();
            
            let node = match clob.orders().get(key) {
                Some(n) => n,
                None => break,
            };
            
            let order_id = node.order.id;
            let user_id = node.order.user_id;
            let maker_remaining = node.remaining();
            
            // Calculate fill quantity
            let fill_qty = remaining.min(maker_remaining);
            let fully_filled = fill_qty >= maker_remaining;
            
            matches.push((key, order_id, user_id, fill_qty, fully_filled));
            
            remaining -= fill_qty;
            current_key = node.next;
        }
        
        matches
    }
    
    /// Remove a fully filled ask order
    fn remove_ask_order(&self, clob: &mut CLOB, key: usize, order_id: u64, price: u64) {
        // Get the node's linked list pointers first
        let (prev_key, next_key) = {
            let node = clob.orders().get(key).unwrap();
            (node.prev, node.next)
        };
        
        // Update the previous node's next pointer
        if let Some(prev) = prev_key {
            if let Some(prev_node) = clob.orders_mut().get_mut(prev) {
                prev_node.next = next_key;
            }
        }
        
        // Update the next node's prev pointer
        if let Some(next) = next_key {
            if let Some(next_node) = clob.orders_mut().get_mut(next) {
                next_node.prev = prev_key;
            }
        }
        
        // Update the price level's head/tail
        if let Some(level) = clob.asks_mut().get_mut(&price) {
            if level.head == Some(key) {
                level.head = next_key;
            }
            if level.tail == Some(key) {
                level.tail = prev_key;
            }
            level.order_count = level.order_count.saturating_sub(1);
        }
        
        // Remove from slab
        clob.remove_from_slab(key);
        
        // Remove from index
        clob.remove_from_index(order_id);
        
        // Decrement count
        clob.decrement_ask_count();
    }
    
    /// Remove a fully filled bid order
    fn remove_bid_order(&self, clob: &mut CLOB, key: usize, order_id: u64, price: u64) {
        // Get the node's linked list pointers first
        let (prev_key, next_key) = {
            let node = clob.orders().get(key).unwrap();
            (node.prev, node.next)
        };
        
        // Update the previous node's next pointer
        if let Some(prev) = prev_key {
            if let Some(prev_node) = clob.orders_mut().get_mut(prev) {
                prev_node.next = next_key;
            }
        }
        
        // Update the next node's prev pointer
        if let Some(next) = next_key {
            if let Some(next_node) = clob.orders_mut().get_mut(next) {
                next_node.prev = prev_key;
            }
        }
        
        // Update the price level's head/tail
        if let Some(level) = clob.bids_mut().get_mut(&Reverse(price)) {
            if level.head == Some(key) {
                level.head = next_key;
            }
            if level.tail == Some(key) {
                level.tail = prev_key;
            }
            level.order_count = level.order_count.saturating_sub(1);
        }
        
        // Remove from slab
        clob.remove_from_slab(key);
        
        // Remove from index
        clob.remove_from_index(order_id);
        
        // Decrement count
        clob.decrement_bid_count();
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Check if prices are compatible for matching.
///
/// # Arguments
///
/// * `incoming_side` - Side of the incoming order
/// * `incoming_price` - Price of the incoming order
/// * `book_price` - Price of the resting order
///
/// # Returns
///
/// `true` if the orders can match
#[inline]
pub fn is_price_compatible(incoming_side: Side, incoming_price: u64, book_price: u64) -> bool {
    match incoming_side {
        // Buy order matches if book price <= incoming price
        Side::Buy => book_price <= incoming_price,
        // Sell order matches if book price >= incoming price
        Side::Sell => book_price >= incoming_price,
    }
}

// ============================================================================
// Unit Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    
    fn create_buy_order(id: u64, price: u64, quantity: u64) -> Order {
        Order::new(id, 100, Side::Buy, price, quantity, 0)
    }
    
    fn create_sell_order(id: u64, price: u64, quantity: u64) -> Order {
        Order::new(id, 100, Side::Sell, price, quantity, 0)
    }
    
    #[test]
    fn test_simple_match() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add resting sell order
        clob.add_order(create_sell_order(1, 5_000_000_000_000, 100_000_000));
        
        // Incoming buy order should match
        let buy = create_buy_order(2, 5_000_000_000_000, 100_000_000);
        let result = engine.match_order(&mut clob, buy, 1000);
        
        assert!(result.fully_filled);
        assert_eq!(result.trades.len(), 1);
        assert_eq!(result.trades[0].price, 5_000_000_000_000);
        assert_eq!(result.trades[0].quantity, 100_000_000);
        assert_eq!(result.trades[0].maker_order_id, 1);
        assert_eq!(result.trades[0].taker_order_id, 2);
        
        // Book should be empty
        assert!(clob.is_empty());
    }
    
    #[test]
    fn test_partial_fill() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add resting sell order for 1 unit
        clob.add_order(create_sell_order(1, 5_000_000_000_000, 100_000_000));
        
        // Incoming buy order for 2 units
        let buy = create_buy_order(2, 5_000_000_000_000, 200_000_000);
        let result = engine.match_order(&mut clob, buy, 1000);
        
        assert!(!result.fully_filled);
        assert_eq!(result.remaining, 100_000_000);
        assert_eq!(result.trades.len(), 1);
        assert!(result.resting_key.is_some());
        
        // Remaining should rest on book
        assert_eq!(clob.order_count(), 1);
        assert_eq!(clob.bid_count(), 1);
        assert_eq!(clob.best_bid(), Some(5_000_000_000_000));
    }
    
    #[test]
    fn test_no_match() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add resting sell order at 51000
        clob.add_order(create_sell_order(1, 5_100_000_000_000, 100_000_000));
        
        // Incoming buy order at 50000 (won't match)
        let buy = create_buy_order(2, 5_000_000_000_000, 100_000_000);
        let result = engine.match_order(&mut clob, buy, 1000);
        
        assert!(!result.fully_filled);
        assert_eq!(result.remaining, 100_000_000);
        assert!(result.trades.is_empty());
        assert!(result.resting_key.is_some());
        
        // Both orders should be on book
        assert_eq!(clob.order_count(), 2);
    }
    
    #[test]
    fn test_price_priority() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add asks at different prices (out of order)
        clob.add_order(create_sell_order(1, 5_200_000_000_000, 100_000_000)); // 52000
        clob.add_order(create_sell_order(2, 5_000_000_000_000, 100_000_000)); // 50000
        clob.add_order(create_sell_order(3, 5_100_000_000_000, 100_000_000)); // 51000
        
        // Buy should match against lowest ask first
        let buy = create_buy_order(4, 5_200_000_000_000, 100_000_000);
        let result = engine.match_order(&mut clob, buy, 1000);
        
        assert!(result.fully_filled);
        assert_eq!(result.trades.len(), 1);
        assert_eq!(result.trades[0].price, 5_000_000_000_000); // Matched at 50000
        assert_eq!(result.trades[0].maker_order_id, 2);
    }
    
    #[test]
    fn test_time_priority() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add multiple orders at same price (FIFO)
        clob.add_order(create_sell_order(1, 5_000_000_000_000, 100_000_000));
        clob.add_order(create_sell_order(2, 5_000_000_000_000, 100_000_000));
        clob.add_order(create_sell_order(3, 5_000_000_000_000, 100_000_000));
        
        // Buy should match against first order added
        let buy = create_buy_order(4, 5_000_000_000_000, 100_000_000);
        let result = engine.match_order(&mut clob, buy, 1000);
        
        assert!(result.fully_filled);
        assert_eq!(result.trades.len(), 1);
        assert_eq!(result.trades[0].maker_order_id, 1); // First order matched
        
        // Two orders should remain
        assert_eq!(clob.order_count(), 2);
    }
    
    #[test]
    fn test_multi_level_match() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add asks at different prices
        clob.add_order(create_sell_order(1, 5_000_000_000_000, 100_000_000)); // 50000
        clob.add_order(create_sell_order(2, 5_100_000_000_000, 100_000_000)); // 51000
        
        // Buy enough to cross both levels
        let buy = create_buy_order(3, 5_100_000_000_000, 200_000_000);
        let result = engine.match_order(&mut clob, buy, 1000);
        
        assert!(result.fully_filled);
        assert_eq!(result.trades.len(), 2);
        
        // First trade at 50000, second at 51000
        assert_eq!(result.trades[0].price, 5_000_000_000_000);
        assert_eq!(result.trades[1].price, 5_100_000_000_000);
        
        // Book should be empty
        assert!(clob.is_empty());
    }
    
    #[test]
    fn test_sell_matches_bids() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Add bids at different prices
        clob.add_order(create_buy_order(1, 4_900_000_000_000, 100_000_000)); // 49000
        clob.add_order(create_buy_order(2, 5_100_000_000_000, 100_000_000)); // 51000
        clob.add_order(create_buy_order(3, 5_000_000_000_000, 100_000_000)); // 50000
        
        // Sell should match against highest bid first
        let sell = create_sell_order(4, 4_900_000_000_000, 100_000_000);
        let result = engine.match_order(&mut clob, sell, 1000);
        
        assert!(result.fully_filled);
        assert_eq!(result.trades.len(), 1);
        assert_eq!(result.trades[0].price, 5_100_000_000_000); // Matched at 51000
        assert_eq!(result.trades[0].maker_order_id, 2);
    }
    
    #[test]
    fn test_determinism() {
        // Run same sequence twice and verify identical results
        fn run_sequence() -> Vec<Trade> {
            let mut clob = CLOB::with_capacity(100);
            let mut engine = MatchingEngine::new();
            let mut all_trades = Vec::new();
            
            // Add orders
            clob.add_order(create_sell_order(1, 5_000_000_000_000, 100_000_000));
            clob.add_order(create_sell_order(2, 5_000_000_000_000, 200_000_000));
            clob.add_order(create_sell_order(3, 5_100_000_000_000, 100_000_000));
            
            // Match orders
            let buy1 = create_buy_order(4, 5_000_000_000_000, 150_000_000);
            let result1 = engine.match_order(&mut clob, buy1, 1000);
            all_trades.extend(result1.trades);
            
            let buy2 = create_buy_order(5, 5_100_000_000_000, 200_000_000);
            let result2 = engine.match_order(&mut clob, buy2, 2000);
            all_trades.extend(result2.trades);
            
            all_trades
        }
        
        let trades1 = run_sequence();
        let trades2 = run_sequence();
        
        // Results must be identical
        assert_eq!(trades1.len(), trades2.len());
        for (t1, t2) in trades1.iter().zip(trades2.iter()) {
            assert_eq!(t1.maker_order_id, t2.maker_order_id);
            assert_eq!(t1.taker_order_id, t2.taker_order_id);
            assert_eq!(t1.price, t2.price);
            assert_eq!(t1.quantity, t2.quantity);
        }
    }
    
    #[test]
    fn test_is_price_compatible() {
        // Buy order: matches if book_price <= incoming_price
        assert!(is_price_compatible(Side::Buy, 5_000_000_000_000, 4_900_000_000_000));
        assert!(is_price_compatible(Side::Buy, 5_000_000_000_000, 5_000_000_000_000));
        assert!(!is_price_compatible(Side::Buy, 5_000_000_000_000, 5_100_000_000_000));
        
        // Sell order: matches if book_price >= incoming_price
        assert!(is_price_compatible(Side::Sell, 5_000_000_000_000, 5_100_000_000_000));
        assert!(is_price_compatible(Side::Sell, 5_000_000_000_000, 5_000_000_000_000));
        assert!(!is_price_compatible(Side::Sell, 5_000_000_000_000, 4_900_000_000_000));
    }
    
    #[test]
    fn test_trade_record_fields() {
        let mut clob = CLOB::with_capacity(100);
        let mut engine = MatchingEngine::new();
        
        // Create orders with specific user IDs
        let sell = Order::new(1, 100, Side::Sell, 5_000_000_000_000, 100_000_000, 0);
        let buy = Order::new(2, 200, Side::Buy, 5_000_000_000_000, 100_000_000, 0);
        
        clob.add_order(sell);
        let result = engine.match_order(&mut clob, buy, 12345);
        
        assert_eq!(result.trades.len(), 1);
        let trade = &result.trades[0];
        
        assert_eq!(trade.id, 1); // First trade ID
        assert_eq!(trade.maker_order_id, 1);
        assert_eq!(trade.taker_order_id, 2);
        assert_eq!(trade.maker_user_id, 100);
        assert_eq!(trade.taker_user_id, 200);
        assert_eq!(trade.price, 5_000_000_000_000);
        assert_eq!(trade.quantity, 100_000_000);
        assert_eq!(trade.timestamp, 12345);
    }
}
